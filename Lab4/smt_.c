// Group 11 Members: Sagar Sharma (368058), Teodora Anitoaei (368014), Varun Gowtham  (368053)
#include <unistd.h>
#include <pthread.h>
#include <sched.h>
#include <sys/syscall.h>
#include <errno.h>
#include <stdint.h>
#include <stdio.h>
#include <stdbool.h>
//define the number here with the core assigned to you
#define CPUID_SMT0 4
#define CPUID_SMT1 (CPUID_SMT0+6)
#define BUSY_TIME 2
//enable and disable your SMT thread
#define SMT1_ON 1

static int fibonacci(int n){
  if(n==0){
    return 0;
  }
  else{
    if(n==1)
      return 1;
    else
      return (fibonacci(n-1)+fibonacci(n-2));
  }
}

static void *tf_smt0(void *targ){
  cpu_set_t mask;
  CPU_ZERO(&mask);
  CPU_SET(CPUID_SMT0, &mask);
  pid_t tid = syscall(SYS_gettid); //glibc does not provide a wrapper for gettid
  sched_setaffinity(tid, sizeof(cpu_set_t), &mask);

  printf("Fibonacci number 40 = %d\n", fibonacci(40));

  pthread_exit(NULL);
}

static void *tf_smt1(void *targ){
  cpu_set_t mask;
  CPU_ZERO(&mask);
  CPU_SET(CPUID_SMT1, &mask);
  pid_t tid = syscall(SYS_gettid); //glibc does not provide a wrapper for gettid
  sched_setaffinity(tid, sizeof(cpu_set_t), &mask);
  int exp(float x){return fibonacci((int) x);}
  double z = 0;
  uint32_t n = 0;
  // ***************************************** Assignment 4: SMT Documentation Start **************************************
  // Goal of the assignment is to keep the tf_smt1 thread run along with tf_smt0 with Simultaneous Multithreading on Intel Corei7 3930K 
  // processor which works with Sandy Bridge Architecture. tf_smt0 is performing calculation of fibonacci series for number 40. Assignment
  // is to come up with a code for the tf_smt1 which uses as much less resources as possible used in fibonacci. 
  // given code had an infinite loop while(1){} in tf_smt1. 
  // Problem: The tf_smt1  as a consequence of while(1) loop used a constant reiterating jmp instruction in the form of "addr: jmp addr". 
  // With a constant "jmp addr" instructions issued from the tf_smt1, this needed to use the ALU for address calculation thus contending 
  // for ALU with tf_smt0 where fibonacci function using the ALU. 
  // 
  // Solution: We had to make the while loop iterate much slowly such that it did not interfere with fibonacci function. 
  // We used floating point arithmetic operations to slow down the while loop as well as keep the tf_smt1 thread occupied with instructions
  // using as less commonly used by the fibonacci function. 

  // further we altered the infinite while loop, while(1) to a finite loop. This was made to trick the compiler to include the code 
  // given in the loop. Without this method compiler was not adding the code or not considering the code given in the while loop. (This 
  // was determined by seeing the assembly code generated by the compiler). 

  // In the while loop, we will see the different floating point operations used and also alterations made to least interfere with the 
  // operation of tf_smt0. 
  while (n < UINT32_MAX){ 
        int32_t i = 32, j = 34, k = 35;
  	double a[2] = {0,0};
        double x[2] = {10.0,20.0};
        double y[2] = {20.0,30.0};
        bool switchs = false;
                	for(uint32_t k =0; k < UINT32_MAX; k++){
				if(switchs){
                                	a[0] = x[0] /  y[1] / i / j /k; // "divsd %xmm0,%xmm3" instruction probably used in intrinsics
                                                                        // format by the compiler to compute results
                                        a[1] = x[1] / y[0] / i / j / k;
					a[0] = x[1] / y[0] / i /  j  / k;
                                        a[1] = x[0] / y[1] / i / j / k;
                                        switchs = !switchs;
                                 }
                                 else{
                                 	a[0] = x[1] / y[0] / i /  j  / k; // "divsd %xmm0,%xmm3" instruction probably used in intrinsics
                                                                          // format by the compiler to compute results
                                        a[1] = x[0] / y[1] / i / j / k;
                                        a[0] = x[0] / y[0] / i / j /k;
                                        a[1] = x[1] / y[1] / i / j / k;
                                        switchs = !switchs;
                                 }
		         } // use of divsd instruction considerably slows down the execution in while loop iteration
                           // added to this are the other movapd, mov, jne, xor which also slow the execution of tf_smt1 
                  

         n++;
         z = a[0];
  }
  z = exp(z); // This was added to consume the result from the while loop. Else the compiler was ignoring the code in the while loop
  // **************************************** Assignment 4: SMT Documentation End ********************************************
  printf("This should not appear\n");
  pthread_exit(NULL);
}

static int64_t diff(struct timespec start, struct timespec end)
{
  struct timespec temp;
  int64_t d;
  if ((end.tv_nsec-start.tv_nsec)<0) {
      temp.tv_sec = end.tv_sec-start.tv_sec-1;
      temp.tv_nsec = 1000000000+end.tv_nsec-start.tv_nsec;
  } else {
      temp.tv_sec = end.tv_sec-start.tv_sec;
      temp.tv_nsec = end.tv_nsec-start.tv_nsec;
  }
  d = temp.tv_sec*1000000000+temp.tv_nsec;
  return d;
}

int main ()
{
  pthread_t smt0, smt1;
  struct timespec start, end;

  clock_gettime(CLOCK_REALTIME,&start);

  pthread_create(&smt0, NULL, tf_smt0, NULL);
#if SMT1_ON
  pthread_create(&smt1, NULL, tf_smt1, NULL);
#endif

  pthread_join(smt0, NULL);
  clock_gettime(CLOCK_REALTIME,&end);
#if SMT1_ON
  pthread_cancel(smt1);
#endif

  double time = (double) diff(start,end)/1000000;
  printf("\nExecution time thread SMT0 \t %.3f ms\n", time);

  return 0;
}
